------------------------------------------------------------------------------

                                    C L I P

-------------------------------------------------------------------------------

        Acronym: Combination of  `Calibration Lidar Internal Parameters'



                                    Contents
                                    --------

     I-





                                      MEX
                                ================

Inside the directory mex/ there is a thin wrapper around matlab's external
interface (MEX), using this interface is straightforward. You can wrap an
existing mxArray* like

 <code>
  #include "mex/mexmat.h"
  void mexFunction(int nlhs, mxArray* plhs[], int nrhs, mxArray const* prhs[])
  {
    const mex::Mat<double>(prhs[0]);
  }
 </code>

If the underlying type mxArray does not match the template type of the wrapper,
you will get an error.

You can also create your own matrix

 <code>
   mex::Mat<float> M(3,5);
 </code>


Memory for this class  will be managed internally. If you would like to return
the variable back to Matlab, you will have to 'release' it. E.g.:

  <code>
     plhs[0] = my_mat.release();
  </code>

Otherwise, the array data will be destroyed at the end of the object's life.


There is 'magic' Makefile that takes care of building mex apps automatically. If
you want to add another app it must have the postfix "_mex.cc". The makefile
will automatically search for this filenames and link them against Matlab's MEX.
Note, any of these files must have a MEX entry point, i.e.

 <code>
  void mexFunction(int, mxArray*[], int, mxArray const*[]) {}
 </code>

Otherwise, you will get a linker error.


This has been tested on Linux box, specifically Debian Wheezy.


